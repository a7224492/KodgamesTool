backtrace：显示栈信息。简写为bt。

     2. frame x 切换到第x帧。其中x会在bt命令中显示，从0开始。0表示栈顶。简写为f。

     3. up/down x 往栈顶/栈底移动x帧。当不输入x时，默认为1。

     4. print x打印x的信息，x可以是变量，也可以是对象或者数组。简写为p。

     5. print */&x 打印x的内容/地址。

     6. call 调用函数。注意此命令需要一个正在运行的程序。

     7. set substitute-path from_path  to_path，替换源码文件路径。当编译机与运行程序的机器代码路径不同时，需要使用该指令替换代码路径，否则你无法在gdb中看到源码。

     8. break x.cpp:n 在x.cpp的第n行设置断点，然后gdb会给出断点编号m。命令可简写为b。后面会对break命令进行更详细的解释。

     9. command m 设置程序执行到断点m时要看的内容，例如：

        command n

          >printf "x is %d\n",x

          >c

          >end

        如果command后面没有参数n，则命令被赋给最后一个breakpoint，这其实是说break和command连在一起用，在脚本里用就非常方便了。gdb脚本会在后面详细介绍

     10. x /nfu ${addr} 打印addr的内容。addr可以是任何合法的地址表达式，例如0x562fb3d，一个当前有效的指针变量p，或者一个当前有效的变量var的地址&var。nfu是格式，n表示查看的长度，F表示格式（例如16进制或10进制），U表示单位（例如单字节b，双字h，四字w等）。举个栗子：

           (gdb) x /3xw 0x562fb3d //这个指令的意思为：以16进制格式显示地址0x562fb3d处3个单位，每个单位四字节的内容。你将得到下列数值：

           0x562fb3d:    0x00282ff4    0x080484e0    0x00000000

     11. continue 继续运行程序。进入调试模式后，若你已经获取了你需要的信息或者需要程序继续运行时使用。可简写为c

     12. until 执行到当前循环完成。可简写为u

     13. step 单步调试，步入当前函数。可简写为s

     14. next 单步调试，步过当前函数。可简写为n

     15. finish 执行到当前函数返回

     16. set var x=10 改变当前变量x的值。也可以这样用：set {int}0x83040 = 10把内存地址0x83040的值强制转换为int并赋值为10

     17. info locals 打印当前栈帧的本地变量

     18. jump使当前执行的程序跳转到某一行，或者跳转到某个地址。由于只会使程序跳转而不会改变栈值，因此若跳出函数到另外的地方 会导致return出错。另外，熟悉汇编的人都知道，程序运行时，有一个寄存器用于保存当前代码所在的内存地址。所以，jump命令也就是改变了这个寄存器中的值。于是，你可以使用“set $pc”来更改跳转执行的地址。如： set $pc = 0x485

     19. return: 强制函数返回。可以指定返回值