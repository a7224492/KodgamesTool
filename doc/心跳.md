- 短连接和长连接
    - 短连接就是connect -> 一次send -> 一次read -> 关闭连接，也就是一次通信后关闭就是短连接
    - 长连接就是connection -> 不止一次send -> 不止一次read，也就是完成一次通信后，连接任然存在，不会关闭
- TCP层心跳
    - TCP层心跳机制？
        - [RFC中关于tcp心跳的说明](https://tools.ietf.org/html/rfc1122#page-101)
        - 翻译
        - 实现者可能会包含keep-alives在他们具体的实现当中，虽然这一选项并没有被普遍接受。如果keep-alives被包含在实现中，应用程序应该可以对任意一个连接打开或者关闭这一选项，默认情况下，这一选项应该是关闭的。
        - 仅当在一段时间内没有收到连接的数据或确认包时，才能发送保持活动的包。这个时间间隔一定要是可配的，默认情况下，不少于两个小时
        - 特别重要的一点是，不包含数据的ACK确认包不是通过tcp可靠地传输的。因此，如果实现了keep-alive机制，它就不能将响应任何特定探测的失败解释为死连接。
        - 具体实现应该发送一个没有数据的keep-alive段（为什么这里用段而前面的描述用ACK确认包？）。然而，这个行为可能是可以配置成发送一个包含垃圾八位字节的keep-alive段，为了兼容一些错误的tcp实现（为什么？）
        - 讨论：
            - 当连接处于空闲的时候，即使没有数据发送的时候，keep-alive机制也会间断地探测连接的另一端。TCP规范中并没有包含keep-alive机制，原因如下
                - 短暂的internet故障期间，导致完全良好的连接中断
                - 消耗没必要的带宽（如果没有人使用这个连接，谁会关心它是否连接良好？）
                - 对于按包收费的因特网路径来说会消耗更多的money
            - 然而，有一些实现包含了keep-alive机制。为了保证闲置的连接仍然是活跃的，这些实现会发送一个可以从对端得到响应包的探测包这样的段通常包含SEG.SEQ=SND.NXT-1并且包含或者不包含垃圾字节。因此，探测包会使接收者返回一个确认段证明自己还活着。如果对等端由于网络分区或崩溃而放弃连接，它将使用RST响应，而不是应答段
            - 不幸的是，一些错误的tcp实现不能够响应带有SEG.SEQ=SND.NXT-1的段，除非这个段包含数据。另外，具体的实现可以判断对端是否能够正确响应没有垃圾数据的keep-alive包
            - TCP keep-alive机制应该在服务端被调用，否则，如果客户端崩溃或者由于网络故障退出了连接，服务器应用程序可能会无限地悬挂并且浪费资源
    - 发送一个数据包给对端后一段时间没有响应，会重传吗？是的
    - 为什么需要TCP层心跳机制？
- 应用层心跳
    - 为什么需要应用层心跳？
        - 心跳可以让应用程序知道对端是否还存活，避免向不存活的对端发送消息导致带宽的浪费
    - 一般的应用层心跳怎么设计，也就是以下问题如何解决
    - 闲置多长时间后开始发送心跳探测？
    - 每次心跳探测间隔时间是多少？
    - 总共发送多少次心跳探测？
        - 以上这几个问题的答案还是根据具体的业务情况来决定，只要不是太小，不是太大，没有影响到服务器性能即可
    - 心跳探测在服务器发起还是客户端发起？
        - 服务器发起和客户端发起都是可以的，只要某一端想要知道对端的存活情况，均需要发起心跳探测